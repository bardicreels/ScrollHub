const { Anthropic } = require("@anthropic-ai/sdk")
const fs = require("fs")
const path = require("path")
const OpenAI = require("openai")
const { Particle } = require("scrollsdk/products/Particle.js")

class AbstractPrompt {
  constructor(userPrompt, existingNames, agent, what) {
    this.userPrompt = userPrompt
    this.existingNames = existingNames
    this.agent = agent
    this.what = what
  }
  setResponse(response) {
    this.response = response
    return this
  }

  setDebugLog(completion) {
    this.completion = completion
  }
}

class SimpleCreationPrompt extends AbstractPrompt {
  get systemPrompt() {
    return `You are an expert web developer. Create a website based on this request: "${this.userPrompt}"

Requirements:
- Use only Scroll, vanilla HTML, CSS, and JavaScript (NO frameworks, NO external dependencies)
- Create clean, semantic HTML5
- Make it mobile-responsive
- Follow modern best practices and accessibility guidelines
- Keep it simple but professional
- Include basic SEO meta tags using Scroll
- Use only relative links and no external resources
- Do not put a copyright symbol or all rights reserved in the footer.
- Make it beautiful. Dazzling. Advanced used of CSS.

First suggest a short, memorable domain name ending in .scroll.pub that represents this website. Then provide the website files. Use this exact format:

---domain---
(domain.scroll.pub here)
---index.scroll---
buildHtml
baseUrl https://(domain.scroll.pub here)
metaTags
editButton /edit.html
title (Title here)
style.css
body.html
script.js
---body.html---
(HTML body content here)
---style.css---
(CSS content here)
---script.js---
(JavaScript content here)
---end---`
  }

  get parsedResponse() {
    const { response } = this
    const files = {}

    let currentFile = null
    let currentContent = []
    let suggestedDomain = ""

    for (const line of response.split("\n")) {
      if (line.startsWith("---") && line.endsWith("---")) {
        if (currentFile === "domain" && currentContent.length > 0) {
          suggestedDomain = currentContent.join("").trim()
        } else if (currentFile && currentContent.length > 0) {
          files[currentFile] = currentContent.join("\n")
        }
        currentContent = []
        const fileName = line.replace(/---/g, "")
        if (fileName === "end") break
        currentFile = fileName
      } else if (currentFile) {
        currentContent.push(line)
      }
    }

    if (!suggestedDomain) suggestedDomain = "error"

    // Ensure the suggested domain ends with .scroll.pub
    if (!suggestedDomain.endsWith(".scroll.pub")) {
      suggestedDomain = suggestedDomain.replace(/\.scroll\.pub.*$/, "") + ".scroll.pub"
    }

    // If domain is taken, add numbers until we find a free one
    let finalDomain = suggestedDomain
    let counter = 1
    while (this.existingNames.includes(finalDomain)) {
      const baseName = suggestedDomain.replace(".scroll.pub", "")
      finalDomain = `${baseName}${counter}.scroll.pub`
      counter++
    }

    // Add a default README
    files["readme.scroll"] = `# ${finalDomain}\n\n${this.what} generated by ${this.agent.name} from prompt: ${this.userPrompt}`

    return {
      folderName: finalDomain,
      files
    }
  }
}

class BlogCreationPrompt extends SimpleCreationPrompt {
  get systemPrompt() {
    return `You are an expert web developer. Create a blog based on this request: "${this.userPrompt}"

Requirements:
- Write 2 blog posts. Keep them short. Intelligent. Data backed. Witty.
- Use only Scroll, CSS, and JavaScript (NO frameworks, NO external dependencies)
- Create clean, semantic HTML5
- Make it mobile-responsive
- Follow modern best practices and accessibility guidelines
- Keep it simple but professional
- Include basic SEO meta tags using Scroll
- Use only relative links and no external resources
- Do not put a copyright symbol or all rights reserved in the footer.
- Make it beautiful. Dazzling. Advanced used of CSS.

First suggest a short, memorable domain name ending in .scroll.pub that represents this website. Then provide the website files. Use this exact format:

---domain---
(domain.scroll.pub here)
---index.scroll---
title (blog title here)
header.scroll
printSnippets All
footer.scroll
---(firstPostPermalinkHere).scroll---
title (first post title here)
tags All
header.scroll
(first post content here)
footer.scroll
---(secondPostPermalinkHere).scroll---
title (second post title here)
tags All
header.scroll
(second post content here)
footer.scroll
---header.scroll---
importOnly
buildHtml
buildTxt
homeButton
leftRightButtons
baseUrl https://(domain.scroll.pub here)
metaTags
editButton
editBaseUrl /edit.html?folderName=(domain.scroll.pub here)&fileName=
metaTags
style.css
script.js
container
printTitle
---feed.scroll---
buildRss
printFeed All
---footer.scroll---
importOnly
center
scrollVersionLink
---style.css---
(CSS content here)
---script.js---
(JavaScript content here)
---end---`
  }
}

class AbstractAgent {
  constructor(apiKey, hubFolder) {
    this.apiKey = apiKey
    this.hubFolder = hubFolder
  }
}

class Claude extends AbstractAgent {
  get client() {
    if (!this._client)
      this._client = new Anthropic({
        apiKey: this.apiKey
      })
    return this._client
  }
  name = "Claude"
  async do(prompt) {
    console.log("Sending prompt to claude")
    const { client } = this
    // Call Claude API
    const completion = await client.messages.create({
      model: "claude-3-5-sonnet-20241022",
      max_tokens: 4000,
      temperature: 0.7,
      messages: [{ role: "user", content: prompt.systemPrompt }]
    })
    // Parse Claude's response into domain and files
    const response = completion.content[0].text
    prompt.setDebugLog(completion)
    return prompt.setResponse(response)
  }
}

class OpenAIAgent extends AbstractAgent {}

class DeepSeek extends AbstractAgent {
  get client() {
    if (!this._client)
      this._client = new OpenAI({
        baseURL: "https://api.deepseek.com",
        apiKey: this.apiKey
      })
    return this._client
  }
  name = "DeepSeek"
  async do(prompt) {
    console.log("Sending prompt to deepseek")
    const completion = await this.client.chat.completions.create({
      messages: [{ role: "system", content: prompt.systemPrompt }],
      model: "deepseek-chat"
    })
    const response = completion.choices[0].message.content
    prompt.setDebugLog(completion)
    return prompt.setResponse(response)
  }
}

const AgentClasses = { claude: Claude, deepseek: DeepSeek, openai: OpenAIAgent }

class Agents {
  constructor(hubFolder) {
    this.hubFolder = hubFolder
    this.agents = {}
    const keyPath = path.join(hubFolder, `keys.txt`)
    this.keyFile = fs.existsSync(keyPath) ? Particle.fromDisk(keyPath) : new Particle()
    this.availableAgents.forEach(agent => this.loadAgent(agent))
  }

  availableAgents = "claude deepseek".split(" ")

  loadAgent(name) {
    const { hubFolder } = this
    const apiKey = this.keyFile.get(name)
    if (!apiKey) {
      console.log(`No ${name} API key found. Skipping ${name} agent`)
      return
    } else {
      console.log(`${name} agent loaded.`)
    }
    const agentConstructor = AgentClasses[name]
    this.agents[name] = new agentConstructor(apiKey, hubFolder)
  }

  get allAgents() {
    return Object.values(this.agents)
  }

  availablePrompts = {
    website: SimpleCreationPrompt,
    blog: BlogCreationPrompt
  }

  async createFolderNameAndFilesFromPrompt(userPrompt, existingNames, agentName, promptTemplate = "website") {
    const agent = this.agents[agentName] || this.allAgents[0]
    const promptToUse = this.availablePrompts[promptTemplate]
    const prompt = new promptToUse(userPrompt, existingNames, agent, promptTemplate)
    if (!agent) throw new Error(`Agent ${agentName} not found. Is API key set?`)
    await agent.do(prompt)
    return prompt
  }

  // todo: wire this up
  async createMultipleFoldersFromPrompt(userPrompt, existingNames) {
    return await Promise.all(
      this.allAgents.map(async agent => {
        const prompt = new SimpleCreationPrompt(userPrompt, existingNames)
        await agent.do(prompt)
        return prompt
      })
    )
  }
}

module.exports = { Agents }
